#!/usr/bin/env ruby

# This recipe contains Solr Process monitor.

require 'rubygems'
require 'json'
require 'logger'
require 'date'
require '/opt/nagios/libexec/solr_util.rb'
require '/opt/solr/solrmonitor/rest_client.rb'

logger = Logger.new('/tmp/check_solr_process.log', 10, 1024*1024)
logger.info ""
logger.info ""
logger.info ""
logger.info ""
logger.info ""
logger.info "------------------------------------------------------------------------------------------------------------"
logger.info "Beginning solr process check at #{DateTime.now}"
logger.info "------------------------------------------------------------------------------------------------------------"

port_no = ARGV[0]

# if  recovering_cores_count > 0 && all_ping_ok (recovering_cores)
#   solr_up
# elsif active_cores_count > 0 && all_ping_ok (active_cores)
#   # all cores are active and pingable
#   solr_up
# elsif total_core_count > 0
#   # no core is recovering or active but the node has some cores on it
#   solr_down
# else
#   solr_up
# end

begin

  solr_down = "solrcloud is down |up=0"
  solr_up = "solrcloud is up |up=100"

  host_ip = `hostname -i`.strip
  # Get the solr processes running in the system by grepping for "sol[r]", the [] is a useful trick to avoid matching the ps -ef command itself.
  # For more info - https://unix.stackexchange.com/questions/74185/how-can-i-prevent-grep-from-showing-up-in-ps-results
  solr_process=`ps aux | grep "sol[r]"`

  # It is possible that there can be any other process with name solr.
  # Then ps aux | grep "sol[r]" will not return "" even though the solr service is down.
  # Solr process starting from Oneops will always have -DzkHost.
  # To run in solrcloud mode solr has to be started with either DzkHost or zkRun.
  if !solr_process.include? "-DzkHost="
    logger.info "solr_process = #{solr_process}"
    logger.info "solr_process without -DzkHost command line argument cannot work in cloud mode. Hence declaring it down"
    puts solr_down
  else

    logger.info "Checking cores for ip=#{host_ip}, port=#{port_no}"
    total_cores, active_cores, recovering_cores, down_cores, recovery_failed_cores = check_solr_process_status_based_on_core_health(host_ip, port_no)

    cores_details = Hash.new

    cores_details = {
            "total_cores" => "#{total_cores}",
            "active_cores" => "#{active_cores}",
            "recovering_cores" => "#{recovering_cores}",
            "down_cores" => "#{down_cores}",
            "recovery_failed_cores" => "#{recovery_failed_cores}",
    }

    logger.info "\n\n cores_details => #{JSON.pretty_generate(cores_details)}"

    if(recovering_cores.length > 0) && (ping_cores(host_ip, port_no, recovering_cores, logger))
      logger.info "Following recovering cores exist in the current solr node and they are all pingable. solr is up"
      puts solr_up
    elsif(active_cores.length > 0) && (ping_cores(host_ip, port_no, active_cores, logger))
      logger.info "Following active cores exist in the current solr node and they are all pingable. solr is up"
      puts solr_up
    elsif(total_cores.length > 0)
      logger.info "Following cores exist in the current solr node which are neither active nor recovering. solr is down"
      puts solr_down
    else
      logger.info "None of the conditions to make the solr process down is met. "
      logger.info "No cores available on the current node. So solr process is up"
      puts solr_up
    end

  end
  logger.close

rescue Errno::ECONNREFUSED
  logger.info "Exception occured, declaring solr process down"
  logger.close
  puts "Solr process is down. #{solr_down}"
end


